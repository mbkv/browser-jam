{
  "version": 3,
  "sources": ["../src/tokenizer.ts", "../src/parser.ts", "../src/renderer.ts", "../src/index.ts"],
  "sourcesContent": [
    "export const isCharSpace = (string: string) => {\n  return string === \" \" || string == \"\\n\" || string === \"\\t\" || string === \"\\f\";\n};\n\nexport const isCharDigit = (string: string) => {\n  const charCode = string.charCodeAt(0);\n  const zero = \"0\".charCodeAt(0);\n  const nine = \"9\".charCodeAt(0);\n\n  return charCode >= zero && charCode <= nine;\n};\n\nexport const isCharAlpha = (string: string) => {\n  const charCode = string.charCodeAt(0);\n  const a = \"a\".charCodeAt(0);\n  const z = \"z\".charCodeAt(0);\n  const A = \"A\".charCodeAt(0);\n  const Z = \"Z\".charCodeAt(0);\n\n  return (charCode >= a && charCode <= z) || (charCode >= A && charCode <= Z);\n};\n\nexport const isCharHex = (string: string) => {\n  const charCode = string.charCodeAt(0);\n  const a = \"a\".charCodeAt(0);\n  const f = \"f\".charCodeAt(0);\n  const A = \"A\".charCodeAt(0);\n  const F = \"F\".charCodeAt(0);\n\n  return (\n    isCharDigit(string) ||\n    (charCode >= a && charCode <= f) ||\n    (charCode >= A && charCode <= F)\n  );\n};\n\nexport const isCharBase64 = (string: string) => {\n  return (\n    isCharAlpha(string) ||\n    isCharDigit(string) ||\n    string[0] === \"_\" ||\n    string[0] === \"-\"\n  );\n};\n\nexport class TokenizerContext<State> {\n  returnState: State[] = [];\n\n  constructor(\n    public input: string,\n    public index: number,\n    public state: State,\n  ) {}\n\n  getRest() {\n    return this.input.slice(this.index);\n  }\n\n  peek(length: number) {\n    return this.input.slice(this.index, this.index + length);\n  }\n\n  startsWith(string: string) {\n    return this.peek(string.length) === string;\n  }\n\n  skip(length = 1) {\n    this.index += length;\n  }\n\n  consume() {\n    const char = this.input[this.index];\n    this.index += 1;\n    return char;\n  }\n\n  eof() {\n    return this.index >= this.input.length;\n  }\n\n  reconsume() {\n    this.index -= 1;\n  }\n\n  setState(state: State, returnState?: State) {\n    if (returnState != null) {\n      this.returnState.push(returnState);\n    }\n    this.state = state;\n  }\n\n  popReturnState() {\n    this.state = this.returnState.pop()!;\n  }\n\n  *[Symbol.iterator]() {\n    while (!this.eof()) {\n      yield this.consume();\n    }\n  }\n\n  clone() {\n    const clone = new TokenizerContext(this.input, this.index, this.state);\n    clone.returnState = this.returnState;\n    return clone;\n  }\n\n  set(ctx: TokenizerContext<State>) {\n    this.returnState = ctx.returnState;\n    this.input = ctx.input;\n    this.index = ctx.index;\n    this.state = ctx.state;\n  }\n}\n",
    "import { isCharAlpha, isCharSpace, TokenizerContext } from \"./tokenizer\";\n\nenum TokenEnum {\n  character,\n  tag,\n  doctype,\n}\n\nenum State {\n  data,\n  tagOpen,\n  endTagOpen,\n  tagName,\n  beforeAttributeName,\n  attributeName,\n  afterAttributeName,\n  beforeAttributeValue,\n  attributeValueDoubleQuoted,\n  attributeValueSingleQuoted,\n  attributeValueUnquoted,\n  afterAttributeValueQuoted,\n  selfClosingStartTag,\n  bogusComment,\n  markupDeclarationOpen,\n  comment,\n  doctype,\n  beforeDoctypeName,\n  doctypeName,\n  afterDoctypeName,\n}\n\ninterface CharacterToken {\n  type: TokenEnum.character;\n  character: string;\n}\n\ninterface TagToken {\n  type: TokenEnum.tag;\n  name: string;\n  closing: boolean;\n  attributes: [string, string][];\n  selfClosing: boolean;\n}\n\ninterface DoctypeToken {\n  type: TokenEnum.doctype;\n  doctype: string;\n}\n\n// generating\n\nconst generateCharacterToken = (character: string): CharacterToken => {\n  return {\n    type: TokenEnum.character,\n    character,\n  };\n};\n\nconst generateEmptyTagToken = (closing: boolean): TagToken => {\n  return {\n    type: TokenEnum.tag,\n    name: \"\",\n    closing,\n    attributes: [],\n    selfClosing: false,\n  };\n};\n\nconst generateDoctypeToken = (): DoctypeToken => {\n  return {\n    type: TokenEnum.doctype,\n    doctype: \"\",\n  };\n};\n\n// tokenizering\n\nfunction* tokenizer(input: string) {\n  const s = new TokenizerContext(input, 0, State.data);\n\n  let tagToken: TagToken = generateEmptyTagToken(false);\n  let attribute: [string, string] = [\"\", \"\"];\n  let doctypeToken: DoctypeToken = generateDoctypeToken();\n\n  while (!s.eof()) {\n    const state = s.state;\n    switch (state) {\n      case State.data: {\n        for (const char of s) {\n          if (char === \"<\") {\n            s.setState(State.tagOpen);\n            break;\n          } else {\n            yield generateCharacterToken(char);\n          }\n        }\n        break;\n      }\n      case State.tagOpen: {\n        const char = s.consume();\n        if (char === \"!\") {\n          s.setState(State.markupDeclarationOpen);\n        } else if (char === \"/\") {\n          s.setState(State.endTagOpen);\n        } else if (isCharAlpha(char)) {\n          s.reconsume();\n          tagToken = generateEmptyTagToken(false);\n          s.setState(State.tagName);\n        } else {\n          s.reconsume();\n          s.setState(State.data);\n        }\n        break;\n      }\n      case State.endTagOpen: {\n        // we don't really care about error handling tbh...\n        const char = s.consume();\n        if (isCharAlpha(char)) {\n          s.reconsume();\n          tagToken = generateEmptyTagToken(true);\n          s.setState(State.tagName);\n        } else {\n          s.reconsume();\n          s.setState(State.bogusComment);\n        }\n        break;\n      }\n      case State.tagName: {\n        for (const char of s) {\n          if (isCharSpace(char)) {\n            s.setState(State.beforeAttributeName);\n            break;\n          } else if (char === \"/\") {\n            tagToken.selfClosing = true;\n            s.setState(State.selfClosingStartTag);\n            break;\n          } else if (char === \">\") {\n            yield tagToken;\n            s.setState(State.data);\n            break;\n          } else {\n            tagToken.name += char.toLowerCase();\n          }\n        }\n        break;\n      }\n      case State.beforeAttributeName: {\n        for (const char of s) {\n          if (isCharSpace(char)) {\n            continue;\n          } else if (char === \"/\" || char === \">\") {\n            s.reconsume();\n            s.setState(State.afterAttributeName);\n            break;\n          } else if (char === \"=\") {\n            // TODO\n          } else {\n            attribute = [\"\", \"\"];\n            tagToken.attributes.push(attribute);\n            s.setState(State.attributeName);\n            s.reconsume();\n            break;\n          }\n        }\n        break;\n      }\n      case State.attributeName: {\n        for (const char of s) {\n          if (isCharSpace(char) || char === \"/\" || char === \">\") {\n            s.reconsume();\n            s.setState(State.afterAttributeName);\n            break;\n          } else if (char === \"=\") {\n            s.setState(State.beforeAttributeValue);\n            break;\n          } else {\n            attribute[0] += char.toLowerCase();\n          }\n        }\n        break;\n      }\n      case State.afterAttributeName: {\n        for (const char of s) {\n          if (isCharSpace(char)) {\n            continue;\n          } else if (char === \"/\") {\n            s.setState(State.selfClosingStartTag);\n            break;\n          } else if (char === \"=\") {\n            s.setState(State.beforeAttributeValue);\n            break;\n          } else if (char === \">\") {\n            yield tagToken;\n            s.setState(State.data);\n            break;\n          } else {\n            attribute = [\"\", \"\"];\n            tagToken.attributes.push(attribute);\n            s.setState(State.attributeName);\n            s.reconsume();\n            break;\n          }\n        }\n        break;\n      }\n      case State.beforeAttributeValue: {\n        for (const char of s) {\n          if (isCharSpace(char)) {\n            continue;\n          }\n          s.reconsume();\n          break;\n        }\n        const char = s.consume();\n        if (char === '\"') {\n          s.setState(State.attributeValueDoubleQuoted);\n        } else if (char === \"'\") {\n          s.setState(State.attributeValueSingleQuoted);\n        } else if (char === \">\") {\n          yield tagToken;\n          s.setState(State.data);\n        } else {\n          s.reconsume();\n          s.setState(State.attributeValueUnquoted);\n        }\n        break;\n      }\n      case State.attributeValueDoubleQuoted: {\n        for (const char of s) {\n          if (char === '\"') {\n            s.setState(State.afterAttributeValueQuoted);\n            break;\n          } else {\n            attribute[1] += char;\n          }\n        }\n        break;\n      }\n      case State.attributeValueSingleQuoted: {\n        for (const char of s) {\n          if (char === \"'\") {\n            s.setState(State.afterAttributeValueQuoted);\n            break;\n          } else {\n            attribute[1] += char;\n          }\n        }\n        break;\n      }\n      case State.attributeValueUnquoted: {\n        for (const char of s) {\n          if (isCharSpace(char)) {\n            s.setState(State.beforeAttributeName);\n            break;\n          } else if (char === \">\") {\n            yield tagToken;\n            s.setState(State.data);\n            break;\n          } else {\n            attribute[1] += char;\n          }\n        }\n        break;\n      }\n      case State.afterAttributeValueQuoted: {\n        for (const char of s) {\n          if (isCharSpace(char)) {\n            s.setState(State.beforeAttributeName);\n            break;\n          } else if (char === \"/\") {\n            s.setState(State.selfClosingStartTag);\n            break;\n          } else if (char === \">\") {\n            yield tagToken;\n            s.setState(State.data);\n            break;\n          } else {\n            s.reconsume();\n            s.setState(State.beforeAttributeName);\n            break;\n          }\n        }\n        break;\n      }\n      case State.selfClosingStartTag: {\n        const char = s.consume();\n        if (char === \">\") {\n          tagToken.selfClosing = true;\n          s.setState(State.data);\n        } else {\n          s.reconsume();\n          s.setState(State.beforeDoctypeName);\n        }\n        break;\n      }\n      case State.bogusComment: {\n        for (const char of s) {\n          if (char === \">\") {\n            s.setState(State.data);\n            break;\n          }\n        }\n        break;\n      }\n      case State.markupDeclarationOpen: {\n        const doctype = \"doctype\";\n        if (s.peek(doctype.length).toLowerCase() === doctype) {\n          s.skip(doctype.length);\n          s.setState(State.doctype);\n        } else if (s.peek(2) === \"--\") {\n          s.skip(2);\n          s.setState(State.comment);\n        }\n        break;\n      }\n      case State.comment: {\n        for (const char of s) {\n          if (char === \"-\" && s.peek(2) === \"->\") {\n            s.skip(2);\n            s.setState(State.data);\n            break;\n          }\n        }\n        break;\n      }\n      case State.doctype: {\n        for (const char of s) {\n          if (isCharSpace(char)) {\n            s.setState(State.beforeDoctypeName);\n            break;\n          } else {\n            s.reconsume();\n            s.setState(State.beforeDoctypeName);\n            break;\n          }\n        }\n        break;\n      }\n      case State.beforeDoctypeName: {\n        for (const char of s) {\n          if (isCharSpace(char)) {\n            continue;\n          } else {\n            s.reconsume();\n            doctypeToken = generateDoctypeToken();\n            s.setState(State.doctypeName);\n            break;\n          }\n        }\n        break;\n      }\n      case State.doctypeName: {\n        for (const char of s) {\n          if (isCharSpace(char)) {\n            s.setState(State.afterDoctypeName);\n            break;\n          } else if (char === \">\") {\n            yield doctypeToken;\n            s.setState(State.data);\n            break;\n          } else {\n            doctypeToken.doctype += char.toLowerCase();\n          }\n        }\n        break;\n      }\n      case State.afterDoctypeName: {\n        for (const char of s) {\n          if (isCharSpace(char)) {\n            continue;\n          } else if (char === \">\") {\n            s.setState(State.data);\n            yield doctypeToken;\n            break;\n          }\n        }\n        break;\n      }\n      default: {\n        const _v: never = state;\n      }\n    }\n  }\n}\n\n// end of compliance starts around here. I just start spitballing here writing\n// in disgusting hacks\n\nexport class TextNode {\n  constructor(\n    public parent: Node,\n    public text: string,\n  ) {}\n\n  get textContext() {\n    return this.text.replace(/\\s+/g, \" \");\n  }\n\n  hasParent(node: Node) {\n    return this.parent.hasParent(node);\n  }\n\n  debug() {\n    return this.text;\n  }\n\n  html(indent = 0) {\n    return \" \".repeat(indent) + this.textContext;\n  }\n}\n\ninterface INode {\n  tag: string;\n  attributes: Record<string, string>;\n  childNodes: (TextNode | INode)[];\n}\n\nexport class Node implements INode {\n  childNodes: (Node | TextNode)[] = [];\n  public constructor(\n    public tag: string,\n    public attributes: Record<string, string> = {},\n    public parent: Node | undefined,\n  ) {}\n\n  hasParent(node: Node) {\n    let current: Node | undefined = this;\n    while (current) {\n      if (node === current) {\n        return true;\n      }\n      current = current.parent;\n    }\n\n    return false;\n  }\n\n  *visit(): Generator<Node | TextNode> {\n    for (let i = 0; i < this.childNodes.length; i++) {\n      const node = this.childNodes[i];\n      yield node;\n\n      if (node instanceof Node) {\n        for (const subnode of node.visit()) {\n          yield subnode;\n        }\n      }\n    }\n  }\n\n  *getElementsByTagname(tagname: string): Generator<Node> {\n    for (const node of this.visit()) {\n      if (node instanceof Node && node.tag === tagname) {\n        yield node;\n      }\n    }\n  }\n\n  debug(): DebugNode {\n    const { parent, childNodes, ...rest } = this;\n    return {\n      ...rest,\n      childNodes: childNodes.map((child) => child.debug()),\n    };\n  }\n\n  html(indent = 0): string {\n    const nextLevelIndent = this.tag === \"\" ? indent : indent + 2;\n    const children = this.childNodes\n      .map((node) => node.html(nextLevelIndent))\n      .join(\"\\n\");\n    if (this.tag === \"\") {\n      return children;\n    }\n    let attributes = \"\";\n    for (const [key, value] of Object.entries(this.attributes)) {\n      attributes += \" \";\n      attributes += `${key}=\"${value}\"`;\n    }\n    const indentation = \" \".repeat(indent);\n    return `${indentation}<${this.tag}${attributes}>\\n${children}\\n${indentation}</${this.tag}>`;\n  }\n}\n\ntype RemoveMethods<T> = {\n  [P in keyof T as T[P] extends Function ? never : P]: T[P];\n};\n\ntype DebugNode = RemoveMethods<Omit<Node, \"parent\" | \"childNodes\">> & {\n  childNodes: (string | DebugNode)[];\n};\n\nconst voidTags = [\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n];\nconst impliedEndTags = [\n  \"dd\",\n  \"dt\",\n  \"li\",\n  \"optgroup\",\n  \"option\",\n  \"p\",\n  \"rb\",\n  \"rp\",\n  \"rt\",\n  \"rtc\",\n];\n\nconst generateImpliedEndTags = [...impliedEndTags, \"dl\"];\n\nexport const parse = (input: string) => {\n  const root = new Node(\"\", {}, undefined);\n  let node = root;\n  const tokens = [...tokenizer(input)];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    switch (token.type) {\n      case TokenEnum.doctype: {\n        // lol don't care rendering at html5 no matter what\n        break;\n      }\n      case TokenEnum.tag: {\n        if (token.closing) {\n          // look up and see if there's a node we can close\n          let current = node;\n          while (current) {\n            if (token.name === current.tag) {\n              console.assert(current.parent, \"closed 1 too many nodes lol\");\n              node = current.parent!;\n              break;\n            }\n            current = current.parent!;\n          }\n        } else {\n          if (generateImpliedEndTags.includes(token.name)) {\n            // gotta check and see if we need to close anything in the tree\n            let current = node;\n            while (current) {\n              if (impliedEndTags.includes(current.tag)) {\n                node = current.parent!;\n                break;\n              }\n              current = current.parent!;\n            }\n          }\n          const newNode = new Node(\n            token.name,\n            Object.fromEntries(token.attributes),\n            node,\n          );\n          node.childNodes.push(newNode);\n          if (voidTags.includes(token.name)) {\n          } else {\n            node = newNode;\n          }\n        }\n        break;\n      }\n      case TokenEnum.character: {\n        const textnode = new TextNode(node, \"\");\n        while (i < tokens.length && tokens[i].type === TokenEnum.character) {\n          textnode.text += (tokens[i] as CharacterToken).character;\n          i += 1;\n        }\n        node.childNodes.push(textnode);\n        i -= 1;\n      }\n    }\n  }\n  return root;\n};\n",
    "import { Node, TextNode } from \"./parser\";\nimport { isCharSpace } from \"./tokenizer\";\n\ninterface Style {\n  display?: \"none\" | \"inline\" | \"block\";\n  color?: string;\n  \"font-size\"?: number;\n  \"margin-left\"?: number;\n  \"margin-top\"?: number;\n  \"margin-bottom\"?: number;\n  \"font-weight\"?: string;\n  \"text-decoration\"?: string;\n}\n\nconst FONT = \"Times New Roman\";\n\nconst defaultStyles = {\n  \"*\": {\n    display: \"block\",\n  },\n  title: {\n    display: \"none\",\n  },\n  h1: {\n    display: \"block\",\n    \"font-size\": 32,\n    \"margin-top\": 22,\n    \"margin-bottom\": 22,\n    \"font-weight\": \"bold\",\n  },\n  h2: {\n    display: \"block\",\n    \"font-size\": 24,\n    \"margin-top\": 20,\n    \"margin-bottom\": 20,\n    \"font-weight\": \"bold\",\n  },\n  a: {\n    display: \"inline\",\n    color: \"blue\",\n    \"text-decoration\": \"underline\",\n  },\n  p: {\n    display: \"block\",\n    \"margin-top\": 16,\n    \"margin-bottom\": 16,\n  },\n  dl: {\n    display: \"block\",\n    \"margin-top\": 16,\n    \"margin-bottom\": 16,\n  },\n  dt: { display: \"block\" },\n  dd: {\n    display: \"block\",\n    \"margin-left\": 40,\n  },\n} satisfies Record<string, Style>;\n\ninterface TextNodeRenderInfo {\n  // left: number;\n  // top: number;\n  // right: number;\n  // bottom: number;\n  text: string;\n  size?: number;\n  color?: string;\n  weight?: string;\n  underline?: boolean;\n  parent: Node;\n}\n\ninterface TextNodeRenderCtx {\n  size?: number;\n  color?: string;\n  weight?: string;\n  underline?: boolean;\n}\n\n// interface LayoutContext {\n//   left: number;\n//   top: number;\n//   marginLeft: number;\n//   marginTop: number;\n//   color?: string;\n//   weight?: string;\n//   underline?: boolean;\n//   previousCharacterWasSpace?: boolean;\n// }\n//\n// type NodeStack = ({node : Node | TextNode, ctx : LayoutContext})[];\n\n// interface Block {\n//   left: number;\n//   top: number;\n//   width: number;\n//   height: number;\n//   marginLeft: number;\n//   marginTop: number;\n// }\n\ninterface Block2 {\n  block: Node;\n  style: Style;\n  elements: TextNodeRenderInfo[];\n}\n\nconst getStylesForTag = (tag: string) => {\n  return defaultStyles[tag as keyof typeof defaultStyles] ?? defaultStyles[\"*\"];\n};\n\nfunction generateBlocks(body: Node) {\n  let block: Block2 = {\n    block: body,\n    style: getStylesForTag(body.tag),\n    elements: [],\n  };\n  const blocks: Block2[] = [block];\n  interface Stack {\n    node: Node | TextNode;\n    ctx: TextNodeRenderCtx;\n  }\n  const stack: Stack[] = [{ node: body, ctx: {} }];\n\n  while (stack.length) {\n    const { node, ctx } = stack.pop()!;\n\n    if (!node.hasParent(block.block)) {\n      block = {\n        block: node.parent!,\n        style: getStylesForTag(node.parent!.tag),\n        elements: [],\n      };\n      blocks.push(block);\n    }\n\n    if (node instanceof Node) {\n      const styles = getStylesForTag(node.tag);\n\n      if (styles.display === \"block\") {\n        block = { block: node, style: styles, elements: [] };\n        blocks.push(block);\n      } else if (styles.display === \"none\") {\n        continue;\n      }\n\n      const newCtx = {\n        ...ctx,\n      };\n      if (\"font-size\" in styles) {\n        newCtx.size = styles[\"font-size\"];\n      }\n      if (\"color\" in styles) {\n        newCtx.color = styles.color;\n      }\n      if (\"text-decoration\" in styles) {\n        newCtx.underline = styles[\"text-decoration\"].includes(\"underline\");\n      }\n      if (\"font-weight\" in styles) {\n        newCtx.weight = styles[\"font-weight\"];\n      }\n\n      for (let i = node.childNodes.length - 1; i >= 0; i--) {\n        stack.push({ node: node.childNodes[i], ctx: newCtx });\n      }\n    } else {\n      block.elements.push({\n        parent: node.parent,\n        text: node.textContext,\n        ...ctx,\n      });\n    }\n  }\n\n  // we'll normalize here as well. gotta get rid of any empty or\n  // leading/trailing whitespace\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    let shouldRemoveLeading = true;\n    for (let i = 0; i < block.elements.length; i++) {\n      const element = block.elements[i];\n      if (shouldRemoveLeading) {\n        element.text = element.text.replace(/^\\s+/, \"\");\n      }\n      if (element.text.length === 0) {\n      } else if (isCharSpace(element.text[element.text.length - 1])) {\n        shouldRemoveLeading = true;\n      } else {\n        shouldRemoveLeading = false;\n      }\n    }\n\n    for (let i = block.elements.length - 1; i >= 0; i--) {\n      const element = block.elements[i];\n      element.text = element.text.replace(/\\s+$/, \"\");\n      if (element.text.length) {\n        break;\n      }\n    }\n  }\n\n  // now remove all empty blocks\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    block.elements = block.elements.filter((element) => element.text);\n    if (block.elements.length === 0) {\n      blocks.splice(i, 1);\n      i--;\n    }\n  }\n\n  return blocks;\n}\n\nconst drawText = (\n  ctx: CanvasRenderingContext2D,\n  elements: TextNodeRenderInfo[],\n  width: number,\n  blockLeft: number,\n  blockTop: number,\n) => {\n  const ratio = window.devicePixelRatio;\n  ctx.textBaseline = \"alphabetic\";\n  ctx.textAlign = \"left\";\n  let left = blockLeft;\n  let top = blockTop;\n  let maxHeight = 0;\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    const size = (element.size ?? 16) * ratio;\n    ctx.font = `${element.weight ?? \"normal\"} ${size}px ${FONT}`;\n    ctx.fillStyle = element.color ?? \"black\";\n    ctx.strokeStyle = element.color ?? \"black\";\n    maxHeight = Math.max(maxHeight, size);\n\n    let textLeftToWrite = element.text;\n    while (textLeftToWrite) {\n      // just write one word at a time\n      const index = textLeftToWrite.indexOf(\" \");\n      let text = \"\";\n      if (index < 0) {\n        text = textLeftToWrite;\n        textLeftToWrite = \"\";\n      } else {\n        text = textLeftToWrite.slice(0, index + 1);\n        textLeftToWrite = textLeftToWrite.slice(index + 1);\n      }\n      const measured = ctx.measureText(text);\n      if (measured.width + left > width) {\n        top += size;\n        left = blockLeft;\n      }\n      ctx.fillText(text, left, top + size * 0.75);\n      if (element.underline) {\n        ctx.beginPath();\n        ctx.moveTo(left, top + size * 0.9);\n        ctx.lineTo(left + measured.width, top + size * 0.9);\n        ctx.lineWidth = ratio;\n        ctx.stroke();\n      }\n      left += measured.width;\n    }\n  }\n  return top + maxHeight;\n};\n\nexport const render = (canvas: HTMLCanvasElement, body: Node) => {\n  const ratio = window.devicePixelRatio;\n  const ctx = canvas.getContext(\"2d\")!;\n  const blocks = generateBlocks(body);\n  const width = canvas.width;\n  const globalMargin = 8;\n  let previousMarginBottom = 8;\n  let y = 0;\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    const {\n      \"margin-top\": marginTop,\n      \"margin-bottom\": marginBottom,\n      \"margin-left\": marginLeft,\n    } = block.style;\n    const actualMarginTop = Math.max(marginTop ?? 0, previousMarginBottom) * ratio;\n    y += actualMarginTop;\n    const actualMarginLeft = (globalMargin + (marginLeft ?? 0)) * ratio;\n\n    y = drawText(ctx, block.elements, width, actualMarginLeft, y);\n    previousMarginBottom = marginBottom ?? 0;\n  }\n};\n",
    "import { Node, parse } from \"./parser\";\nimport { render } from \"./renderer\";\n\nconst PROXY_HOST = window.location.href.includes(\"localhost\")\n  ? \"http://localhost:8090\"\n  : \"https://browser.mbkv.io/proxy\";\n\nasync function fetchPage(url: string) {\n  // gotta proxy due to cors errors\n  const proxied = `${PROXY_HOST}/${url}`;\n  const resp = await fetch(proxied);\n  const text = await resp.text();\n\n  return text;\n}\n\nasync function main() {\n  const canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\n  const htmlDisplay = document.getElementById(\n    \"inputhtml\",\n  ) as HTMLTextAreaElement;\n  const addressBar = document.getElementById(\n    \"address-bar\",\n  )! as HTMLInputElement;\n  let text: string | undefined;\n  let html: Node | undefined;\n\n  async function resizeAndRun() {\n    if (html && canvas.parentElement) {\n      const ratio = window.devicePixelRatio;\n      const width = canvas.parentElement.clientWidth;\n      const height = canvas.parentElement.clientHeight;\n      canvas.style.width = `${width}px`;\n      canvas.style.height = `${height}px`;\n      canvas.width = canvas.parentElement.clientWidth * ratio;\n      canvas.height = canvas.parentElement.clientHeight * ratio;\n\n      render(canvas, html);\n    }\n  }\n\n  async function run() {\n    text = await fetchPage(addressBar.value);\n    html = parse(text);\n    htmlDisplay.textContent = html.html();\n\n    resizeAndRun();\n  }\n\n  const observer = new ResizeObserver(() => {\n    resizeAndRun();\n  });\n  observer.observe(canvas.parentElement!);\n\n\n  addressBar.addEventListener(\"blur\", run);\n  run();\n}\n\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", main);\n} else {\n  main();\n}\n"
  ],
  "mappings": "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",
  "debugId": "795FECBC02B00BF764756E2164756E21",
  "names": []
}